{"config":{"lang":["en"],"separator":"[\\\\s\\\\-,:!=\\\\[\\\\]()\\\"`/]+|\\\\.(?!\\\\d)|&[lg]t;|(?!\\\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Logust","text":"<p> Fast, Rust-powered Python logging inspired by loguru </p> <p> </p> <p>14x faster than loguru, 4x faster than logging</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install logust\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import logust\n\nlogust.info(\"Hello, Logust!\")\nlogust.debug(\"Debug message\")\nlogust.warning(\"Warning message\")\nlogust.error(\"Error message\")\n</code></pre> <pre><code>2025-12-24 15:52:42.199 | INFO     | Hello, Logust!\n2025-12-24 15:52:42.199 | DEBUG    | Debug message\n2025-12-24 15:52:42.199 | WARNING  | Warning message\n2025-12-24 15:52:42.199 | ERROR    | Error message\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Blazing Fast - Rust-powered core delivers 5-24x faster performance</li> <li>Beautiful by Default - Colored output with zero configuration</li> <li>Simple API - loguru-compatible interface for easy migration</li> <li>File Management - Size/time-based rotation, retention policies, gzip compression</li> <li>JSON Support - Built-in serialization for structured logging</li> <li>Context Binding - Attach metadata to log records with <code>bind()</code></li> <li>Exception Handling - Automatic traceback capture with <code>catch()</code> decorator</li> </ul>"},{"location":"#from-hello-to-production","title":"From Hello to Production","text":"HelloProduction <pre><code>import logust\n\nlogust.info(\"Hello, Logust!\")\nlogust.warning(\"Heads up\")\n</code></pre> <pre><code>from logust import logger\n\nlogger.add(\n    \"app.log\",\n    level=\"INFO\",\n    rotation=\"500 MB\",\n    retention=\"30 days\",\n    compression=True,\n    serialize=True,\n    enqueue=True,\n)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation - Get started with Logust</li> <li>Quick Start - Learn the basics</li> <li>File Output - Rotation, retention, compression</li> <li>Formatting - Custom formats and JSON</li> <li>Comparison - Logust vs loguru vs logging</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Quick reference for the public API. For examples, see the Guide.</p>"},{"location":"api/#overview","title":"Overview","text":"<ul> <li>Logger: Log methods, handlers, levels, context, options, callbacks</li> <li>LogLevel: Enum values for severity</li> <li>Parsing: <code>parse()</code> and <code>parse_json()</code> helpers</li> </ul>"},{"location":"api/#logger","title":"Logger","text":"<p>The main logging interface.</p>"},{"location":"api/#log-methods","title":"Log methods","text":"<pre><code>logger.trace(message, **kwargs)\nlogger.debug(message, **kwargs)\nlogger.info(message, **kwargs)\nlogger.success(message, **kwargs)\nlogger.warning(message, **kwargs)\nlogger.error(message, **kwargs)\nlogger.fail(message, **kwargs)\nlogger.critical(message, **kwargs)\nlogger.exception(message, **kwargs)  # ERROR with traceback\nlogger.log(level, message, **kwargs)  # Any level\n</code></pre>"},{"location":"api/#handler-management","title":"Handler management","text":"<pre><code># File sink\nhandler_id = logger.add(\n    sink,                    # File path (str or Path), sys.stdout/stderr, or callable\n    level=None,              # Minimum level (LogLevel or str)\n    format=None,             # Format string\n    rotation=None,           # \"500 MB\", \"daily\", \"hourly\" (files only)\n    retention=None,          # \"10 days\" or count (int) (files only)\n    compression=False,       # Gzip compression (files only)\n    serialize=False,         # JSON output\n    filter=None,             # Filter function\n    enqueue=False,           # Async writes (files only)\n    colorize=None,           # ANSI colors (console only, auto-detect if None)\n    collect=None,            # CollectOptions for info collection control\n)\n\n# Console sink\nimport sys\nlogger.add(sys.stdout, colorize=True)   # stdout with colors\nlogger.add(sys.stderr, serialize=True)  # stderr with JSON\n\n# Callable sink (function, lambda, method)\nlogger.add(lambda msg: print(msg))\nlogger.add(my_function, format=\"{level} | {message}\")\nlogger.add(send_to_slack, level=\"ERROR\", serialize=True)\n\nlogger.remove(handler_id)    # Remove specific\nlogger.remove()              # Remove all\nlogger.complete()            # Flush pending writes\n</code></pre>"},{"location":"api/#level-control","title":"Level control","text":"<pre><code>logger.set_level(level)      # Set minimum level\nlogger.get_level()           # Get current level\nlogger.is_level_enabled(level)  # Check if enabled\n\nlogger.enable(level=None)    # Enable console\nlogger.disable()             # Disable console\nlogger.is_enabled()          # Check if enabled\n</code></pre>"},{"location":"api/#custom-levels","title":"Custom levels","text":"<pre><code>logger.level(\n    name,           # Level name (str)\n    no,             # Numeric value (int)\n    color=None,     # Color name (str)\n    icon=None,      # Icon symbol (str)\n)\n</code></pre>"},{"location":"api/#context","title":"Context","text":"<pre><code>new_logger = logger.bind(**kwargs)\n\nwith logger.contextualize(**kwargs):\n    logger.info(\"With context\")\n\n# Patch modifies record dict before logging\ndef add_hostname(record):\n    record[\"extra\"][\"hostname\"] = socket.gethostname()\n\npatched = logger.patch(add_hostname)\npatched.info(\"Message\")  # Includes hostname in extra\n\n# Multiple patchers accumulate\nlogger.patch(f1).patch(f2).info(\"Both patchers applied\")\n</code></pre>"},{"location":"api/#exception-handling","title":"Exception handling","text":"<pre><code>@logger.catch(\n    exception=Exception,     # Exception type(s)\n    level=\"ERROR\",           # Log level\n    reraise=False,           # Re-raise after logging\n    message=\"An error occurred\",\n)\ndef function():\n    pass\n</code></pre>"},{"location":"api/#options","title":"Options","text":"<pre><code>opt_logger = logger.opt(\n    lazy=False,       # Lazy evaluation\n    exception=False,  # Capture current exception\n    depth=0,          # Stack frame offset\n    backtrace=False,  # Extended traceback\n    diagnose=False,   # Show variable values\n)\n\n# opt_logger supports all log methods with format arguments:\nopt_logger.info(\"Value: {}\", value)\nopt_logger.debug(\"User {} did {}\", user_id, action)\n</code></pre>"},{"location":"api/#callbacks","title":"Callbacks","text":"<pre><code>callback_id = logger.add_callback(callback, level=None)\nlogger.remove_callback(callback_id)\n</code></pre>"},{"location":"api/#configuration","title":"Configuration","text":"<pre><code>handler_ids = logger.configure(\n    handlers=[\n        {\"sink\": \"app.log\", \"level\": \"INFO\", \"rotation\": \"1 day\"},\n        {\"sink\": \"error.log\", \"level\": \"ERROR\"},\n        {\"sink\": \"app.json\", \"serialize\": True},\n    ],\n    levels=[\n        {\"name\": \"NOTICE\", \"no\": 25, \"color\": \"cyan\"},\n    ],\n    extra={\"app\": \"myapp\"},  # Bound to all logs\n    patcher=my_patcher,      # Applied to all logs\n)\n</code></pre>"},{"location":"api/#loglevel","title":"LogLevel","text":"<p>Enum for log levels.</p> <pre><code>from logust import LogLevel\n\nLogLevel.Trace      # 5\nLogLevel.Debug      # 10\nLogLevel.Info       # 20\nLogLevel.Success    # 25\nLogLevel.Warning    # 30\nLogLevel.Error      # 40\nLogLevel.Fail       # 45\nLogLevel.Critical   # 50\n</code></pre>"},{"location":"api/#type-definitions","title":"Type definitions","text":""},{"location":"api/#logrecord","title":"LogRecord","text":"<pre><code>from logust import LogRecord\n\nrecord: LogRecord = {\n    \"level\": \"INFO\",\n    \"level_no\": 20,\n    \"message\": \"Hello\",\n    \"timestamp\": \"2025-12-24T12:00:00\",\n    \"name\": \"__main__\",           # Module name\n    \"function\": \"my_function\",    # Function name\n    \"line\": 42,                   # Line number\n    \"file\": \"main.py\",            # Source file name\n    \"thread_name\": \"MainThread\",  # Thread name\n    \"thread_id\": 12345,           # Thread ID\n    \"process_name\": \"MainProcess\", # Process name\n    \"process_id\": 1234,           # Process ID\n    \"elapsed\": \"00:01:23.456\",    # Time since logger start\n    \"exception\": None,\n    \"extra\": {\"user_id\": \"123\"},\n}\n</code></pre>"},{"location":"api/#collectoptions","title":"CollectOptions","text":"<p>Control what information is collected per handler. Useful for performance optimization.</p> <pre><code>from logust import CollectOptions, CallerInfo, ThreadInfo, ProcessInfo\n\n# Auto-detect from format (default)\nlogger.add(\"app.log\", collect=CollectOptions())\n\n# Disable caller collection for performance\nlogger.add(\"fast.log\", collect=CollectOptions(caller=False))\n\n# Use fixed values (avoid stack inspection)\nlogger.add(\"fixed.log\", collect=CollectOptions(\n    caller=CallerInfo(name=\"myapp\", function=\"main\", line=1, file=\"app.py\"),\n    thread=ThreadInfo(name=\"Worker\", id=1),\n    process=ProcessInfo(name=\"App\", id=1000),\n))\n\n# Force collection even if format doesn't need it\nlogger.add(\"full.log\", collect=CollectOptions(caller=True, thread=True, process=True))\n</code></pre> <p>Each field can be:</p> <ul> <li><code>None</code> - Auto-detect from format string (default)</li> <li><code>False</code> - Never collect (use empty defaults)</li> <li><code>True</code> - Always collect dynamically</li> <li><code>CallerInfo</code>/<code>ThreadInfo</code>/<code>ProcessInfo</code> - Use fixed values</li> </ul>"},{"location":"api/#callerinfo","title":"CallerInfo","text":"<p>Fixed caller information for log records.</p> <pre><code>from logust import CallerInfo\n\ncaller = CallerInfo(\n    name=\"mymodule\",      # Module name\n    function=\"handler\",   # Function name\n    line=42,              # Line number\n    file=\"handler.py\",    # Source file name\n)\n</code></pre>"},{"location":"api/#threadinfo","title":"ThreadInfo","text":"<p>Fixed thread information for log records.</p> <pre><code>from logust import ThreadInfo\n\nthread = ThreadInfo(\n    name=\"WorkerThread\",  # Thread name\n    id=12345,             # Thread ID\n)\n</code></pre>"},{"location":"api/#processinfo","title":"ProcessInfo","text":"<p>Fixed process information for log records.</p> <pre><code>from logust import ProcessInfo\n\nprocess = ProcessInfo(\n    name=\"MainProcess\",   # Process name\n    id=1234,              # Process ID\n)\n</code></pre>"},{"location":"api/#recordlevel","title":"RecordLevel","text":"<pre><code>from logust import RecordLevel\n\nlevel = RecordLevel(name=\"INFO\", no=20, icon=\"\")\n</code></pre>"},{"location":"api/#recordexception","title":"RecordException","text":"<pre><code>from logust import RecordException\n\nexc = RecordException(\n    type=ValueError,\n    value=ValueError(\"error\"),\n    traceback=\"...\",\n)\n</code></pre>"},{"location":"api/#parsing","title":"Parsing","text":""},{"location":"api/#parse","title":"parse()","text":"<p>Parse log files with regex patterns:</p> <pre><code>from logust import parse\n\nfor record in parse(\"app.log\", r\"(?P&lt;level&gt;\\w+) \\| (?P&lt;message&gt;.*)\"):\n    print(record[\"level\"], record[\"message\"])\n</code></pre>"},{"location":"api/#parse_json","title":"parse_json()","text":"<p>Parse JSON log files:</p> <pre><code>from logust import parse_json\n\nfor record in parse_json(\"app.json\"):\n    print(record[\"level\"], record[\"message\"])\n</code></pre>"},{"location":"api/#performance","title":"Performance","text":""},{"location":"api/#automatic-optimization","title":"Automatic optimization","text":"<p>Logust automatically optimizes based on your format string:</p> <pre><code># Fast: no caller info collected (~0.7 \u00b5s/log)\nlogger.add(\"fast.log\", format=\"{time} | {level} - {message}\")\n\n# Slower: caller info collected (~1.2 \u00b5s/log)\nlogger.add(\"full.log\", format=\"{time} | {level} | {name}:{function}:{line} - {message}\")\n</code></pre> <p>The format is analyzed at handler creation time, and only required information is collected.</p>"},{"location":"api/#manual-optimization-with-collectoptions","title":"Manual optimization with CollectOptions","text":"<p>For maximum performance, explicitly disable unused collection:</p> <pre><code>from logust import CollectOptions\n\n# Skip all extra info collection\nlogger.add(\"minimal.log\",\n    format=\"{time} | {level} - {message}\",\n    collect=CollectOptions(caller=False, thread=False, process=False)\n)\n</code></pre>"},{"location":"api/#callable-sinks","title":"Callable sinks","text":"<p>Callable sinks automatically analyze their format string:</p> <pre><code># Format analyzed - caller info NOT collected\nlogger.add(my_func, format=\"{time} | {level} - {message}\")\n\n# Format analyzed - caller info IS collected\nlogger.add(my_func, format=\"{name}:{line} - {message}\")\n</code></pre>"},{"location":"api/#performance-tips","title":"Performance tips","text":"<ol> <li>Use simple formats - Avoid <code>{name}</code>, <code>{function}</code>, <code>{line}</code> if not needed</li> <li>Use <code>enqueue=True</code> - For high-throughput file writes (no async overhead in Logust)</li> <li>Use <code>CollectOptions</code> - Explicitly disable unused fields for critical paths</li> <li>Use fixed info - Provide <code>CallerInfo</code>/<code>ThreadInfo</code>/<code>ProcessInfo</code> to avoid dynamic lookup</li> </ol>"},{"location":"comparison/","title":"Comparison","text":""},{"location":"comparison/#at-a-glance","title":"At a glance","text":""},{"location":"comparison/#logust","title":"Logust","text":"<ul> <li>Rust core and high throughput</li> <li>Loguru-style API</li> <li>Rotation, retention, JSON, async writes</li> </ul>"},{"location":"comparison/#loguru","title":"Loguru","text":"<ul> <li>Rich sink options</li> <li>More built-in record fields</li> <li>Long-established ecosystem</li> </ul>"},{"location":"comparison/#logging","title":"logging","text":"<ul> <li>Standard library</li> <li>Very configurable but verbose</li> <li>Slower by default</li> </ul>"},{"location":"comparison/#benchmarks-10000-messages","title":"Benchmarks (10,000 messages)","text":"<p>Results are from the included benchmark suite (<code>benchmarks/bench_throughput.py</code>).</p>"},{"location":"comparison/#summary","title":"Summary","text":"<pre><code>logust vs loguru:  14x faster on average\nlogust vs logging: 4x faster on average\n</code></pre> <p>Logust includes rich caller information (module, function, line) in every log message while maintaining excellent performance.</p>"},{"location":"comparison/#throughput","title":"Throughput","text":"Scenario logging loguru logust vs loguru File write (sync) 59 ms 64 ms 13 ms 5x faster Formatted messages 58 ms 67 ms 14 ms 5x faster JSON serialize N/A 137 ms 13 ms 11x faster Context binding N/A 65 ms 13 ms 5x faster"},{"location":"comparison/#async-writes","title":"Async writes","text":"Scenario loguru logust vs loguru File write (async) 307 ms 13 ms 24x faster"},{"location":"comparison/#sync-vs-async-latency","title":"Sync vs Async latency","text":"<p>This measures main thread time only - the true benefit of async is not blocking I/O.</p> Library Sync Async Effect loguru 68 ms 354 ms 5x slower logust 14 ms 16 ms No overhead <p>Key finding: loguru's <code>enqueue=True</code> adds significant overhead due to Python's <code>queue.Queue</code>. Logust uses Rust's lock-free crossbeam channels, maintaining speed while offloading I/O.</p>"},{"location":"comparison/#feature-comparison","title":"Feature comparison","text":"Feature logust loguru Colored output Yes Yes File rotation Yes Yes File retention Yes Yes Compression Yes Yes JSON output Yes Yes Context binding Yes Yes Custom levels Yes Yes Exception catching Yes Yes Lazy evaluation Yes Yes Async writes Yes Yes Callable sinks Yes Yes Stack info (module, function, line) Yes Yes Process/thread info Yes Yes"},{"location":"comparison/#api-differences","title":"API differences","text":"<p>Most loguru code works with logust with minimal changes:</p> <pre><code># loguru\nfrom loguru import logger\nlogger.add(\"app.log\", rotation=\"500 MB\")\nlogger.info(\"Hello\")\n\n# logust (same API for common usage)\nfrom logust import logger\nlogger.add(\"app.log\", rotation=\"500 MB\")\nlogger.info(\"Hello\")\n</code></pre>"},{"location":"comparison/#when-to-choose-logust","title":"When to choose logust","text":"<ul> <li>Performance and throughput are critical</li> <li>You want a loguru-style API with fewer dependencies</li> <li>You need rotation, retention, JSON, callable sinks, and async writes</li> </ul>"},{"location":"comparison/#when-to-choose-loguru","title":"When to choose loguru","text":"<ul> <li>You need full loguru compatibility for advanced features</li> <li>You need richer built-in record fields or sink options</li> </ul>"},{"location":"comparison/#logust-vs-standard-logging","title":"Logust vs standard logging","text":""},{"location":"comparison/#advantages-of-logust","title":"Advantages of logust","text":"<ol> <li>Zero configuration with readable defaults</li> <li>Better performance out of the box</li> <li>Simpler API with fewer moving parts</li> <li>Built-in rotation, retention, and colors</li> </ol>"},{"location":"comparison/#migration-example","title":"Migration example","text":"<pre><code># Standard logging\nimport logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s | %(levelname)s | %(message)s\",\n    handlers=[\n        logging.FileHandler(\"app.log\"),\n        logging.StreamHandler(),\n    ],\n)\nlogger = logging.getLogger(__name__)\nlogger.info(\"Hello\")\n\n# Logust (simpler)\nfrom logust import logger\nlogger.add(\"app.log\")\nlogger.info(\"Hello\")\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Get Logust from PyPI in seconds, or build from source for local Rust changes.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>No Rust needed</p> <p>Pre-built wheels available for all platforms. No Rust toolchain required.</p> <ul> <li>Python 3.10+</li> <li>Linux, macOS, Windows</li> </ul>"},{"location":"getting-started/installation/#install","title":"Install","text":"pipuvsource <pre><code>pip install logust\n</code></pre> <pre><code>uv add logust\n</code></pre> <pre><code>git clone https://github.com/yamaaaaaa31/logust.git\ncd logust\n\nuv venv &amp;&amp; source .venv/bin/activate\nuv pip install maturin\nmaturin develop --release\n</code></pre> <p>Rust required</p> <p>Source builds require Rust stable and a working cargo toolchain. On Windows, activate with <code>.venv\\\\Scripts\\\\activate</code>.</p>"},{"location":"getting-started/installation/#verify","title":"Verify","text":"<pre><code>python -c \"import logust; logust.info('Logust installed')\"\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next steps","text":"<ul> <li>Quick start</li> <li>File output</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get a logger in one line, then add configuration when you need it.</p> <p>loguru compatible</p> <p>Same API as loguru - easy migration from existing code.</p>"},{"location":"getting-started/quick-start/#choose-your-style","title":"Choose your style","text":"Module-levelLogger instance <pre><code>import logust\n\nlogust.info(\"Hello, Logust!\")\nlogust.debug(\"Debug message\")\nlogust.warning(\"Warning message\")\nlogust.error(\"Error message\")\n</code></pre> <pre><code>from logust import logger\n\nlogger.info(\"Info message\")\nlogger.debug(\"Debug message\")\nlogger.success(\"Success message\")\n</code></pre>"},{"location":"getting-started/quick-start/#set-the-minimum-level","title":"Set the minimum level","text":"<pre><code>from logust import logger, LogLevel\n\nlogger.set_level(LogLevel.Warning)\nlogger.info(\"This will not be shown\")\nlogger.warning(\"This will be shown\")\n</code></pre>"},{"location":"getting-started/quick-start/#add-a-file-sink","title":"Add a file sink","text":"<pre><code>from logust import logger\n\nlogger.add(\"app.log\")\nlogger.add(\"error.log\", level=\"ERROR\")\n</code></pre>"},{"location":"getting-started/quick-start/#common-recipes","title":"Common recipes","text":"<p>Performance tip</p> <p>Use <code>enqueue=True</code> for async file writes in high-throughput scenarios.</p> <pre><code>from logust import logger\n\n# Rotate and retain\nlogger.add(\"app.log\", rotation=\"500 MB\", retention=\"10 days\")\n\n# JSON output\nlogger.add(\"app.json\", serialize=True)\nlogger.info(\"Structured log\")\n\n# Bind context\nuser_logger = logger.bind(user_id=\"123\")\nuser_logger.info(\"User action\")\n\n# Catch exceptions\n@logger.catch()\ndef risky():\n    return 1 / 0\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next steps","text":"<ul> <li>File output</li> <li>Formatting</li> <li>Context binding</li> <li>Exception handling</li> </ul>"},{"location":"guide/context/","title":"Context Binding","text":"<p>Attach structured data to records without manual string formatting.</p> <p>Best practice</p> <p>Use <code>bind()</code> for request IDs, user IDs, and other metadata that should appear in every log.</p>"},{"location":"guide/context/#overview","title":"Overview","text":"<ul> <li><code>bind()</code> creates a new logger with permanent context.</li> <li><code>contextualize()</code> adds temporary context in a <code>with</code> block.</li> <li><code>patch()</code> modifies records dynamically before they are emitted.</li> </ul>"},{"location":"guide/context/#bind-permanent-context","title":"bind() - Permanent context","text":"<pre><code>from logust import logger\n\nuser_logger = logger.bind(user_id=\"123\", session=\"abc\")\nuser_logger.info(\"User action\")\n</code></pre> <p>With JSON output, extra fields are included:</p> <pre><code>{\n  \"time\": \"2025-12-24T12:00:00\",\n  \"level\": \"INFO\",\n  \"message\": \"User action\",\n  \"extra\": {\n    \"user_id\": \"123\",\n    \"session\": \"abc\"\n  }\n}\n</code></pre>"},{"location":"guide/context/#contextualize-temporary-context","title":"contextualize() - Temporary context","text":"<pre><code>from logust import logger\n\nwith logger.contextualize(request_id=\"abc\"):\n    logger.info(\"Processing\")\n    logger.info(\"Done\")\n\nlogger.info(\"Outside\")\n</code></pre>"},{"location":"guide/context/#nested-contexts","title":"Nested contexts","text":"<pre><code>with logger.contextualize(user_id=\"123\"):\n    logger.info(\"User context\")\n\n    with logger.contextualize(action=\"login\"):\n        logger.info(\"Both user_id and action\")\n\n    logger.info(\"Only user_id\")\n</code></pre>"},{"location":"guide/context/#patch-dynamic-modification","title":"patch() - Dynamic modification","text":"<pre><code>from logust import logger\nimport threading\n\ndef add_thread_info(record):\n    record[\"extra\"][\"thread\"] = threading.current_thread().name\n\npatched_logger = logger.patch(add_thread_info)\npatched_logger.info(\"Thread-aware log\")\n</code></pre>"},{"location":"guide/context/#chaining-patchers","title":"Chaining patchers","text":"<pre><code>def add_request_id(record):\n    record[\"extra\"][\"request_id\"] = get_current_request_id()\n\ndef add_user_id(record):\n    record[\"extra\"][\"user_id\"] = get_current_user_id()\n\nenhanced_logger = logger.patch(add_request_id).patch(add_user_id)\n</code></pre>"},{"location":"guide/context/#use-cases","title":"Use cases","text":""},{"location":"guide/context/#web-request-logging","title":"Web request logging","text":"<pre><code>from logust import logger\n\ndef handle_request(request):\n    req_logger = logger.bind(\n        request_id=request.id,\n        method=request.method,\n        path=request.path,\n    )\n\n    req_logger.info(\"Request started\")\n    # ... process request ...\n    req_logger.info(\"Request completed\")\n</code></pre>"},{"location":"guide/context/#user-session-logging","title":"User session logging","text":"<pre><code>def process_user_action(user, action):\n    with logger.contextualize(user_id=user.id, action=action):\n        logger.info(\"Processing action\")\n</code></pre>"},{"location":"guide/exceptions/","title":"Exception Handling","text":"<p>Pick the pattern that matches your flow.</p> <p>Three ways to log exceptions</p> <p><code>exception()</code> in try/except, <code>@catch()</code> as decorator, or <code>opt(exception=True)</code> for control.</p>"},{"location":"guide/exceptions/#quick-choices","title":"Quick choices","text":"exception()catch()opt(exception=True) <pre><code>from logust import logger\n\ntry:\n    result = 1 / 0\nexcept ZeroDivisionError:\n    logger.exception(\"Division failed\")\n</code></pre> <pre><code>from logust import logger\n\n@logger.catch()\ndef risky_function():\n    return 1 / 0\n\nrisky_function()\n</code></pre> <pre><code>from logust import logger\n\ntry:\n    risky_operation()\nexcept Exception:\n    logger.opt(exception=True).error(\"Operation failed\")\n</code></pre> <p>Note</p> <p>Use <code>except Exception</code> instead of a bare <code>except</code> unless you need to catch <code>BaseException</code> (KeyboardInterrupt, SystemExit).</p>"},{"location":"guide/exceptions/#exception-output","title":"exception() output","text":"<pre><code>2025-12-24 12:00:00 | ERROR | Division failed\nTraceback (most recent call last):\n  File \"example.py\", line 4, in &lt;module&gt;\n    result = 1 / 0\nZeroDivisionError: division by zero\n</code></pre>"},{"location":"guide/exceptions/#catch-options","title":"catch() options","text":"<pre><code>from logust import logger\n\n@logger.catch(reraise=True)\ndef must_succeed():\n    raise ValueError(\"Failed\")\n\n@logger.catch(level=\"WARNING\")\ndef might_fail():\n    raise RuntimeError(\"Oops\")\n\n@logger.catch(message=\"Function failed\")\ndef another_function():\n    raise Exception(\"Error\")\n\n@logger.catch(exception=ValueError)\ndef validate():\n    raise ValueError(\"Invalid\")\n\n@logger.catch(exception=(ValueError, TypeError))\ndef process():\n    raise TypeError(\"Wrong type\")\n</code></pre>"},{"location":"guide/exceptions/#enhanced-diagnostics","title":"Enhanced diagnostics","text":"<p>Show variable values at each stack frame:</p> <pre><code>try:\n    a = 10\n    b = 0\n    result = a / b\nexcept Exception:\n    logger.opt(diagnose=True).error(\"Calculation failed\")\n</code></pre> <p>Extended backtrace beyond the catch point:</p> <pre><code>try:\n    nested_function()\nexcept Exception:\n    logger.opt(backtrace=True).error(\"Deep error\")\n</code></pre>"},{"location":"guide/exceptions/#callbacks-for-error-monitoring","title":"Callbacks for error monitoring","text":"<pre><code>from logust import logger, LogLevel\n\ndef send_to_sentry(record):\n    if record[\"level\"] == \"ERROR\":\n        # sentry_sdk.capture_message(record[\"message\"])\n        pass\n\nlogger.add_callback(send_to_sentry, level=LogLevel.Error)\n</code></pre>"},{"location":"guide/file-output/","title":"File Output","text":"<p>Send logs to files with rotation, retention, and compression.</p> <p>Production best practice</p> <p>Always set <code>rotation</code> and <code>retention</code> in production to prevent disk space issues.</p>"},{"location":"guide/file-output/#basic-file-handler","title":"Basic file handler","text":"<pre><code>from logust import logger\n\nhandler_id = logger.add(\"app.log\")\nlogger.info(\"This goes to app.log\")\n</code></pre>"},{"location":"guide/file-output/#console-sinks-stdoutstderr","title":"Console sinks (stdout/stderr)","text":"<p>In addition to files, you can add handlers for stdout and stderr:</p> <pre><code>import sys\nfrom logust import logger\n\n# Remove default console output\nlogger.remove()\n\n# Add stdout with colors\nlogger.add(sys.stdout, colorize=True)\n\n# Add stderr for JSON output\nlogger.add(sys.stderr, serialize=True)\n\n# Both outputs simultaneously\nlogger.info(\"Goes to both stdout and stderr\")\n</code></pre>"},{"location":"guide/file-output/#colorize-option","title":"Colorize option","text":"<p>Control ANSI color codes in console output:</p> <pre><code>import sys\nfrom logust import logger\n\n# Auto-detect TTY (default when colorize=None)\nlogger.add(sys.stdout)  # Colors if terminal, plain if piped\n\n# Force colors on\nlogger.add(sys.stdout, colorize=True)\n\n# Force colors off\nlogger.add(sys.stdout, colorize=False)\n</code></pre>"},{"location":"guide/file-output/#multiple-outputs-with-different-formats","title":"Multiple outputs with different formats","text":"<pre><code>import sys\nfrom logust import logger\n\nlogger.remove()\n\n# Human-readable console output\nlogger.add(sys.stdout, colorize=True, format=\"{level} | {message}\")\n\n# JSON to stderr for log aggregation\nlogger.add(sys.stderr, serialize=True)\n\n# File for archival\nlogger.add(\"app.log\", rotation=\"daily\", retention=\"30 days\")\n</code></pre>"},{"location":"guide/file-output/#common-recipes","title":"Common recipes","text":"<pre><code>from logust import logger\n\n# Rotate by size\nlogger.add(\"app.log\", rotation=\"500 MB\")\n\n# Rotate by time\nlogger.add(\"app.log\", rotation=\"daily\")\n\n# Keep last N files\nlogger.add(\"app.log\", retention=5)\n\n# Compress rotated files\nlogger.add(\"app.log\", rotation=\"daily\", compression=True)\n</code></pre>"},{"location":"guide/file-output/#handler-options","title":"Handler options","text":"<pre><code># File handler options\nlogger.add(\n    \"app.log\",\n    level=\"INFO\",           # Minimum log level\n    format=\"{time} | {level} | {message}\",  # Custom format\n    rotation=\"500 MB\",      # Rotation strategy\n    retention=\"10 days\",    # Retention policy\n    compression=True,       # Compress rotated files\n    serialize=True,         # JSON output\n    filter=None,            # Filter callback\n    enqueue=False,          # Sync writes (default)\n)\n\n# Console handler options\nlogger.add(\n    sys.stdout,\n    level=\"INFO\",           # Minimum log level\n    format=\"{time} | {level} | {message}\",  # Custom format\n    serialize=False,        # JSON output\n    filter=None,            # Filter callback\n    colorize=True,          # ANSI color codes (console only)\n)\n</code></pre>"},{"location":"guide/file-output/#rotation","title":"Rotation","text":"<p>Rotate log files based on size or time:</p> <pre><code># Size-based rotation\nlogger.add(\"app.log\", rotation=\"500 MB\")\nlogger.add(\"app.log\", rotation=\"1 GB\")\n\n# Time-based rotation\nlogger.add(\"app.log\", rotation=\"daily\")\nlogger.add(\"app.log\", rotation=\"hourly\")\n</code></pre>"},{"location":"guide/file-output/#rotation-options","title":"Rotation options","text":"Value Description <code>\"500 MB\"</code> Rotate when file reaches 500 MB <code>\"1 GB\"</code> Rotate when file reaches 1 GB <code>\"daily\"</code> Rotate daily at midnight <code>\"hourly\"</code> Rotate every hour"},{"location":"guide/file-output/#retention","title":"Retention","text":"<p>Automatically delete old log files:</p> <pre><code># Time-based retention\nlogger.add(\"app.log\", retention=\"10 days\")\nlogger.add(\"app.log\", retention=\"7 days\")\n\n# Count-based retention\nlogger.add(\"app.log\", retention=5)  # Keep last 5 files\n</code></pre>"},{"location":"guide/file-output/#compression","title":"Compression","text":"<p>Compress rotated files with gzip:</p> <pre><code>logger.add(\"app.log\", rotation=\"daily\", compression=True)\n# Creates: app.2024-12-24.log.gz\n</code></pre>"},{"location":"guide/file-output/#json-serialization","title":"JSON serialization","text":"<p>Output logs as JSON for log aggregation systems:</p> <pre><code>logger.add(\"app.json\", serialize=True)\nlogger.info(\"Structured log\")\n</code></pre> <p>Output: <pre><code>{\"time\":\"2025-12-24T12:00:00.123\",\"level\":\"INFO\",\"message\":\"Structured log\"}\n</code></pre></p>"},{"location":"guide/file-output/#async-vs-sync-writes","title":"Async vs sync writes","text":"<pre><code># Synchronous writes (default, reliable)\nlogger.add(\"app.log\", enqueue=False)\n\n# Asynchronous writes (higher throughput)\nlogger.add(\"app.log\", enqueue=True)\n</code></pre> <p>When to use async</p> <p>Use <code>enqueue=True</code> for high-throughput logging where some message loss is acceptable. Use <code>enqueue=False</code> (default) for reliable logging.</p>"},{"location":"guide/file-output/#handler-management","title":"Handler management","text":"<pre><code>handler_id = logger.add(\"app.log\")\n\nlogger.remove(handler_id)  # Remove specific handler\nlogger.remove()            # Remove all handlers\nlogger.complete()          # Flush pending writes\n</code></pre>"},{"location":"guide/file-output/#multiple-handlers","title":"Multiple handlers","text":"<pre><code>from logust import logger\n\nlogger.add(\"app.log\")\nlogger.add(\"error.log\", level=\"ERROR\")\nlogger.add(\"app.json\", serialize=True)\n</code></pre>"},{"location":"guide/formatting/","title":"Formatting","text":"<p>Make logs readable with templates, or switch to JSON.</p> <p>JSON for log aggregation</p> <p>Use <code>serialize=True</code> for structured logging with Elasticsearch, Loki, etc.</p>"},{"location":"guide/formatting/#default-format","title":"Default format","text":"<p>The default log format includes caller information (module, function, line number):</p> <pre><code>{time} | {level:&lt;8} | {name}:{function}:{line} - {message}\n</code></pre> <p>Output: <pre><code>2025-12-24 15:52:42.199 | INFO     | __main__:my_function:10 - Hello, Logust!\n</code></pre></p> <p>This format is similar to uvicorn's log format, making it easy to identify where each log message originated.</p>"},{"location":"guide/formatting/#custom-format","title":"Custom format","text":"<p>Customize the format when adding a handler:</p> <pre><code>from logust import logger\n\nlogger.add(\"app.log\", format=\"{time} | {level} | {message}\")\nlogger.add(\"simple.log\", format=\"[{level}] {message}\")\nlogger.add(\"minimal.log\", format=\"{message}\")\n</code></pre>"},{"location":"guide/formatting/#format-tokens","title":"Format tokens","text":"Token Description Example <code>{time}</code> Timestamp <code>2025-12-24 12:00:00.123</code> <code>{level}</code> Log level name <code>INFO</code> <code>{level:&lt;8}</code> Aligned level (width 8) <code>INFO</code> <code>{message}</code> Log message <code>Hello, world!</code> <code>{name}</code> Module/logger name <code>__main__</code>, <code>myapp.utils</code> <code>{function}</code> Function name <code>process_request</code> <code>{line}</code> Line number <code>42</code> <code>{extra[key]}</code> Extra context fields <code>{extra[user_id]}</code>"},{"location":"guide/formatting/#caller-information","title":"Caller information","text":"<p>The <code>{name}</code>, <code>{function}</code>, and <code>{line}</code> tokens capture the call site:</p> <pre><code># myapp/handler.py, line 15\ndef handle_request():\n    logger.info(\"Processing request\")\n    # Output: myapp.handler:handle_request:15 - Processing request\n</code></pre> <p>When using <code>opt(depth=N)</code>, caller info is adjusted to skip N frames:</p> <pre><code>def wrapper():\n    def inner():\n        logger.opt(depth=1).info(\"From wrapper\")  # Shows 'wrapper', not 'inner'\n    inner()\n</code></pre>"},{"location":"guide/formatting/#extra-fields","title":"Extra fields","text":"<pre><code>from logust import logger\n\nuser_logger = logger.bind(user_id=\"123\", action=\"login\")\nuser_logger.info(\"User action\")\n</code></pre> <p>Format usage:</p> <pre><code>{time} | {level} | {message} | user={extra[user_id]}\n</code></pre>"},{"location":"guide/formatting/#json-output","title":"JSON output","text":"<p>For structured logging, use the <code>serialize</code> option:</p> <pre><code>logger.add(\"app.json\", serialize=True)\n\ndef handle_login():\n    logger.info(\"User logged in\")\n\nhandle_login()\n</code></pre> <p>Output: <pre><code>{\n  \"time\": \"2025-12-24 12:00:00.123\",\n  \"level\": \"INFO\",\n  \"message\": \"User logged in\",\n  \"name\": \"__main__\",\n  \"function\": \"handle_login\",\n  \"line\": 5\n}\n</code></pre></p> <p>Caller information is automatically included in JSON output.</p>"},{"location":"guide/formatting/#json-with-context","title":"JSON with context","text":"<p>When using <code>bind()</code>, extra fields are included:</p> <pre><code>logger.add(\"app.json\", serialize=True)\nuser_logger = logger.bind(user_id=\"123\", action=\"login\")\nuser_logger.info(\"User action\")\n</code></pre> <p>Output: <pre><code>{\n  \"time\": \"2025-12-24T12:00:00.123456\",\n  \"level\": \"INFO\",\n  \"message\": \"User action\",\n  \"extra\": {\n    \"user_id\": \"123\",\n    \"action\": \"login\"\n  }\n}\n</code></pre></p>"},{"location":"guide/formatting/#color-markup","title":"Color markup","text":"<p>Add colors to console output using markup:</p> <pre><code>from logust import logger\n\nlogger.info(\"&lt;red&gt;Error&lt;/red&gt; in &lt;blue&gt;module&lt;/blue&gt;\")\nlogger.info(\"&lt;green&gt;Success!&lt;/green&gt;\")\nlogger.info(\"&lt;bold&gt;Important&lt;/bold&gt; message\")\n</code></pre>"},{"location":"guide/formatting/#available-tags","title":"Available tags","text":"Tag Description <code>&lt;red&gt;</code>, <code>&lt;green&gt;</code>, <code>&lt;blue&gt;</code>, etc. Text colors <code>&lt;bold&gt;</code> Bold text <code>&lt;underline&gt;</code> Underlined text <code>&lt;bright_red&gt;</code>, <code>&lt;bright_green&gt;</code>, etc. Bright colors <p>Note</p> <p>Color markup only works in console output, not in file handlers.</p>"},{"location":"guide/integrations/","title":"Integrations","text":"<p>Logust provides zero-config integrations for common use cases in the <code>logust.contrib</code> module.</p>"},{"location":"guide/integrations/#standard-logging-interception","title":"Standard Logging Interception","text":"<p>Redirect all standard library logging to logust with a single line:</p> <pre><code>from logust.contrib import intercept_logging\n\n# That's it! All logging now goes through logust\nintercept_logging()\n\n# Standard logging calls now use logust\nimport logging\nlogging.info(\"This goes through logust!\")\n\n# Third-party libraries automatically use logust too\nimport requests  # Their logs appear in logust format\n</code></pre>"},{"location":"guide/integrations/#how-it-works","title":"How It Works","text":"<p>The <code>InterceptHandler</code> captures log records from Python's standard <code>logging</code> module and forwards them to logust. This means:</p> <ul> <li>Consistent log formatting across your entire application</li> <li>Third-party library logs use logust's fast Rust core</li> <li>All logs benefit from logust's rotation, retention, and JSON features</li> </ul>"},{"location":"guide/integrations/#manual-setup","title":"Manual Setup","text":"<p>For more control, you can set up the handler manually:</p> <pre><code>import logging\nfrom logust.contrib import InterceptHandler\n\n# Clear existing handlers\nlogging.root.handlers = [InterceptHandler()]\nlogging.root.setLevel(logging.DEBUG)\n</code></pre>"},{"location":"guide/integrations/#function-timing-decorators","title":"Function Timing Decorators","text":"<p>Log function execution time automatically:</p> <pre><code>from logust.contrib import log_fn, debug_fn\n\n@log_fn\ndef process_data(items):\n    # ... processing ...\n    return result\n\nprocess_data([1, 2, 3])\n# Logs: \"Called process_data with elapsed_time=0.123\"\n\n@debug_fn\nasync def fetch_user(user_id):\n    return await db.get_user(user_id)\n\nawait fetch_user(123)\n# Logs at DEBUG: \"Called fetch_user with elapsed_time=0.050\"\n</code></pre>"},{"location":"guide/integrations/#features","title":"Features","text":"<ul> <li>Supports both sync and async functions</li> <li><code>log_fn</code> logs at INFO level</li> <li><code>debug_fn</code> logs at DEBUG level (only appears when DEBUG is enabled)</li> <li>Minimal overhead when log level is disabled</li> </ul>"},{"location":"guide/integrations/#custom-log-level","title":"Custom Log Level","text":"<pre><code>from logust.contrib import log_fn\n\n@log_fn(level=\"WARNING\")\ndef slow_operation():\n    # This will log at WARNING level\n    pass\n</code></pre>"},{"location":"guide/integrations/#fastapi-starlette-middleware","title":"FastAPI / Starlette Middleware","text":"<p>Automatic request/response logging for web applications:</p> <pre><code>from fastapi import FastAPI\nfrom logust.contrib import RequestLoggerMiddleware\n\napp = FastAPI()\napp.add_middleware(RequestLoggerMiddleware)\n\n# All requests are now logged:\n# \"Request started: GET /users ip=127.0.0.1\"\n# \"Request successful: GET /users status=200 time=0.0123s ip=127.0.0.1\"\n</code></pre>"},{"location":"guide/integrations/#configuration-options","title":"Configuration Options","text":"<pre><code>app.add_middleware(\n    RequestLoggerMiddleware,\n    skip_routes=[\"/health\", \"/metrics\"],      # Skip these routes\n    skip_regexes=[r\"^/docs\", r\"^/openapi\"],   # Skip regex patterns\n    include_request_body=True,                 # Log request bodies\n    max_body_size=1000,                        # Truncate large bodies\n    mask_sensitive_data=True,                  # Mask passwords, tokens, etc.\n)\n</code></pre>"},{"location":"guide/integrations/#one-liner-setup","title":"One-Liner Setup","text":"<p>For the quickest setup, use <code>setup_fastapi</code>:</p> <pre><code>from fastapi import FastAPI\nfrom logust.contrib.starlette import setup_fastapi\n\napp = FastAPI()\nsetup_fastapi(app, skip_routes=[\"/health\"])\n\n# This sets up:\n# - Request/response logging\n# - Standard logging redirected to logust\n# - Request IDs in all log messages\n</code></pre>"},{"location":"guide/integrations/#request-id-access","title":"Request ID Access","text":"<p>Access the current request ID anywhere in your code:</p> <pre><code>from logust.contrib.starlette import get_request_id\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    request_id = get_request_id()\n    logger.info(f\"Processing request {request_id}\")\n    # ...\n</code></pre>"},{"location":"guide/integrations/#sensitive-data-masking","title":"Sensitive Data Masking","text":"<p>The middleware automatically masks common sensitive fields:</p> <ul> <li>password, passwd</li> <li>token, access_token, refresh_token, jwt</li> <li>secret, key, api_key</li> <li>authorization, credential</li> </ul> <pre><code># Request body: {\"username\": \"john\", \"password\": \"secret123\"}\n# Logged as:    {\"username\": \"john\", \"password\": \"***\"}\n</code></pre>"},{"location":"guide/integrations/#complete-example","title":"Complete Example","text":"<p>Here's a complete FastAPI application with all integrations:</p> <pre><code>from fastapi import FastAPI\nfrom logust import logger\nfrom logust.contrib import intercept_logging, log_fn\nfrom logust.contrib.starlette import setup_fastapi\n\n# Create app\napp = FastAPI()\n\n# One-liner logust setup\nsetup_fastapi(app, skip_routes=[\"/health\"])\n\n# Add file logging\nlogger.add(\"app.log\", rotation=\"daily\", retention=\"7 days\")\nlogger.add(\"app.json\", serialize=True)\n\n@log_fn\nasync def get_user_from_db(user_id: int):\n    # Simulated DB call\n    return {\"id\": user_id, \"name\": \"John\"}\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int):\n    return await get_user_from_db(user_id)\n\n@app.get(\"/health\")\nasync def health():\n    return {\"status\": \"ok\"}  # Not logged (skipped)\n</code></pre> <p>Output: <pre><code>2025-01-01 12:00:00.123 | INFO     | Request started: GET /users/1 ip=127.0.0.1\n2025-01-01 12:00:00.125 | INFO     | Called get_user_from_db with elapsed_time=0.002\n2025-01-01 12:00:00.126 | INFO     | Request successful: GET /users/1 status=200 time=0.003s ip=127.0.0.1\n</code></pre></p>"},{"location":"guide/integrations/#requirements","title":"Requirements","text":"<p>The base <code>logust.contrib</code> module has no extra dependencies. For web framework integrations:</p> <pre><code># For FastAPI/Starlette middleware\npip install starlette\n# or\npip install fastapi\n</code></pre>"},{"location":"guide/levels/","title":"Log Levels","text":"<p>Use levels to control verbosity, and add your own when needed.</p>"},{"location":"guide/levels/#built-in-levels","title":"Built-in levels","text":"Level Value Color Description TRACE 5 Cyan Detailed debugging information DEBUG 10 Blue Debug information INFO 20 White General information SUCCESS 25 Green Success messages WARNING 30 Yellow Warning messages ERROR 40 Red Error messages FAIL 45 Red Failure messages CRITICAL 50 Red (bold) Critical errors <p>Guard expensive logs</p> <p>Use <code>is_level_enabled()</code> before doing heavy work.</p> <pre><code>from logust import logger\n\nif logger.is_level_enabled(\"DEBUG\"):\n    value = expensive_call()\n    logger.debug(f\"Computed value: {value}\")\n</code></pre>"},{"location":"guide/levels/#set-the-minimum-level","title":"Set the minimum level","text":"EnumString <pre><code>from logust import logger, LogLevel\n\nlogger.set_level(LogLevel.Warning)\n</code></pre> <pre><code>from logust import logger\n\nlogger.set_level(\"warning\")\nlogger.set_level(\"WARNING\")\n</code></pre>"},{"location":"guide/levels/#check-current-level","title":"Check current level","text":"<pre><code>from logust import logger\n\ncurrent = logger.get_level()\nprint(f\"Current level: {current.name}\")\n</code></pre>"},{"location":"guide/levels/#custom-levels","title":"Custom levels","text":"<pre><code>from logust import logger\n\nlogger.level(\"NOTICE\", no=25, color=\"cyan\", icon=\"!\")\nlogger.log(\"NOTICE\", \"This is a notice\")\n</code></pre>"},{"location":"guide/levels/#custom-level-parameters","title":"Custom level parameters","text":"Parameter Type Description <code>name</code> str Level name (uppercase recommended) <code>no</code> int Numeric severity (higher = more severe) <code>color</code> str Color name for console output <code>icon</code> str Icon symbol (optional)"},{"location":"guide/levels/#available-colors","title":"Available colors","text":"<ul> <li><code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, <code>white</code></li> <li>Bright variants: <code>bright_red</code>, <code>bright_green</code>, etc.</li> </ul>"},{"location":"guide/levels/#enable-or-disable-console","title":"Enable or disable console","text":"<pre><code>from logust import logger\n\nlogger.disable()\nlogger.info(\"This will not appear in console\")\n\nlogger.enable()  # Re-enable with previous level\nlogger.enable(level=\"INFO\")  # Re-enable and set minimum level\n</code></pre> <p>The <code>enable()</code> method accepts an optional <code>level</code> parameter to set the minimum console level when re-enabling.</p>"}]}